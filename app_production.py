"""VortexAI Backend - MINIMAL WORKING VERSIONAccepts deal ingestion and responds appropriatelyNO form data endpoints - JSON only"""from fastapi import FastAPI, HTTPException, Dependsfrom fastapi.middleware.cors import CORSMiddlewarefrom contextlib import asynccontextmanagerfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Booleanfrom sqlalchemy.orm import declarative_base, sessionmaker, Sessionfrom sqlalchemy.pool import NullPoolfrom pydantic import BaseModelfrom datetime import datetimeimport osimport jsonimport logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# DatabaseDATABASE_URL = os.getenv("DATABASE_URL", "postgresql://user:pass@localhost/vortexai")engine = create_engine(DATABASE_URL, poolclass=NullPool, echo=False)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base()# Modelsclass Deal(Base):    __tablename__ = "deals"    id = Column(Integer, primary_key=True)    name = Column(String)    email = Column(String)    asset_type = Column(String)    location = Column(String)    price = Column(Float)    ai_score = Column(Float, default=0)    recommendation = Column(String, default="skip")    created_at = Column(DateTime, default=datetime.utcnow)Base.metadata.create_all(bind=engine)# Pydanticclass DealCreate(BaseModel):    name: str    email: str    asset_type: str    location: str    price: floatclass DealResponse(BaseModel):    id: int    name: str    email: str    asset_type: str    location: str    price: float    ai_score: float    created_at: datetime    class Config:        from_attributes = True# Dependencydef get_db():    db = SessionLocal()    try:        yield db    finally:        db.close()# App@asynccontextmanagerasync def lifespan(app: FastAPI):    logger.info(" VortexAI Backend Starting...")    yield    logger.info(" VortexAI Backend Shutting Down...")app = FastAPI(title="VortexAI", version="1.0.0", lifespan=lifespan)app.add_middleware(CORSMiddleware, allow_origins=["*"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"])# Endpoints@app.get("/health")async def health():    return {"status": "healthy", "message": "VortexAI Backend is online", "timestamp": datetime.utcnow()}@app.get("/info")async def info():    return {"system": "VortexAI", "version": "1.0.0"}@app.post("/admin/webhooks/deal-ingest", response_model=DealResponse)async def ingest_deal(deal: DealCreate, db: Session = Depends(get_db)):    """Main deal ingestion endpoint"""    try:        # Validate        if not deal.name or deal.name.lower() == "unknown":            deal.name = "Unknown"        if not deal.email or deal.email.lower() == "unknown":            deal.email = "unknown@local"        if deal.price < 1:            raise HTTPException(status_code=400, detail="Invalid price")                # Simple scoring        score = 50        urgency_words = ["must sell", "urgent", "cash only", "foreclosure", "probate"]        if any(word in deal.name.lower() for word in urgency_words):            score += 20                # Create        db_deal = Deal(            name=deal.name,            email=deal.email,            asset_type=deal.asset_type,            location=deal.location,            price=deal.price,            ai_score=min(100, score),            recommendation="post_urgent" if score > 70 else ("post" if score > 55 else "skip")        )        db.add(db_deal)        db.commit()        db.refresh(db_deal)                logger.info(f" Deal accepted: {deal.name} | Score: {db_deal.ai_score}")        return db_deal    except Exception as e:        db.rollback()        logger.error(f" Error: {str(e)}")        raise HTTPException(status_code=500, detail=str(e))@app.get("/admin/deals")async def get_deals(db: Session = Depends(get_db)):    """Get all deals"""    deals = db.query(Deal).order_by(Deal.created_at.desc()).limit(100).all()    return dealsif __name__ == "__main__":    import uvicorn    uvicorn.run(app, host="0.0.0.0", port=8080)
