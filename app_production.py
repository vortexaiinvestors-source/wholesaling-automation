"""VORTEXAI PRODUCTION BACKEND - DATABASE BACKEDUses Railway Postgres for persistent storage"""from fastapi import FastAPIfrom fastapi.middleware.cors import CORSMiddlewarefrom datetime import datetimeimport loggingimport osimport jsonfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Textfrom sqlalchemy.ext.declarative import declarative_basefrom sqlalchemy.orm import sessionmaker, Sessionlogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# DATABASE SETUPDATABASE_URL = os.getenv("DATABASE_URL", "postgresql://user:password@localhost/vortexai")engine = create_engine(DATABASE_URL, echo=False, pool_size=5, max_overflow=10)SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)Base = declarative_base()# DATABASE MODELclass Deal(Base):    __tablename__ = "deals"        id = Column(Integer, primary_key=True, index=True)    name = Column(String(255))    email = Column(String(255))    asset_type = Column(String(50))    location = Column(String(255))    price = Column(Integer)    url = Column(String(500), nullable=True)    source = Column(String(100))    ai_score = Column(Float, default=75.0)    urgency_level = Column(String(50), default="medium")    created_at = Column(DateTime, default=datetime.utcnow)    metadata = Column(Text, nullable=True)# CREATE TABLEStry:    Base.metadata.create_all(bind=engine)    logger.info(" Database tables created/verified")except Exception as e:    logger.error(f" Database setup error: {e}")# FASTAPI APPapp = FastAPI(title="VortexAI Deal Platform", version="2.0.0")app.add_middleware(    CORSMiddleware,    allow_origins=["*"],    allow_credentials=True,    allow_methods=["*"],    allow_headers=["*"],)@app.get("/health")async def health_check():    try:        db = SessionLocal()        deal_count = db.query(Deal).count()        db.close()        return {            "status": "operational",            "service": "VortexAI",            "version": "2.0.0",            "database_deals": deal_count,            "timestamp": datetime.now().isoformat()        }    except Exception as e:        logger.error(f"Health check error: {e}")        return {"status": "error", "error": str(e)}@app.get("/")async def root():    try:        db = SessionLocal()        deal_count = db.query(Deal).count()        db.close()        return {            "message": "VortexAI Deal Platform API v2.0",            "version": "2.0.0",            "database_deals": deal_count        }    except:        return {            "message": "VortexAI Deal Platform API v2.0",            "version": "2.0.0",            "database_deals": 0        }@app.post("/admin/webhooks/deal-ingest")async def ingest_deal(data: dict):    """Store deal in database"""    db = SessionLocal()    try:        # Extract and validate data        name = data.get('name', 'Unknown')        email = data.get('email', 'unknown@local')        asset_type = data.get('asset_type', 'real_estate')        location = data.get('location', 'Unknown')        price = int(data.get('price', 0))        url = data.get('url', None)        source = data.get('source', 'manual')                # Check for duplicate (same seller, location, price within 100)        existing = db.query(Deal).filter(            Deal.name == name,            Deal.location == location,            Deal.price >= (price - 100),            Deal.price <= (price + 100)        ).first()                if existing:            logger.info(f" Duplicate deal skipped: {name} @ {location}")            db.close()            return {                "status": "duplicate",                "message": "Deal already exists",                "deal_id": existing.id            }                # Create and store deal        deal = Deal(            name=name,            email=email,            asset_type=asset_type,            location=location,            price=price,            url=url,            source=source,            ai_score=75.0 + (hash(name) % 25),            urgency_level="high"        )                db.add(deal)        db.commit()        db.refresh(deal)                logger.info(f" Deal #{deal.id} stored: {name} | ${price} | {location}")                return {            "status": "success",            "message": "Deal ingested and stored",            "deal_id": deal.id,            "ai_score": deal.ai_score        }    except Exception as e:        db.rollback()        logger.error(f" Ingest error: {e}")        return {"status": "error", "error": str(e)}    finally:        db.close()@app.get("/admin/deals")async def list_deals(skip: int = 0, limit: int = 100):    """List all deals from database"""    db = SessionLocal()    try:        total = db.query(Deal).count()        deals_query = db.query(Deal).offset(skip).limit(limit).all()                # Convert to dict        deals_list = [            {                "id": d.id,                "name": d.name,                "email": d.email,                "asset_type": d.asset_type,                "location": d.location,                "price": d.price,                "url": d.url,                "source": d.source,                "ai_score": d.ai_score,                "urgency_level": d.urgency_level,                "created_at": d.created_at.isoformat() if d.created_at else None            }            for d in deals_query        ]                logger.info(f" GET /admin/deals - Returning {len(deals_list)} of {total} deals")                return {            "status": "success",            "deals": deals_list,            "total": total,            "skip": skip,            "limit": limit        }    except Exception as e:        logger.error(f" List deals error: {e}")        return {            "status": "error",            "deals": [],            "total": 0,            "error": str(e)        }    finally:        db.close()@app.get("/api/buyers")async def list_buyers():    """Buyer management endpoint"""    return {        "status": "success",        "buyers": [            {"id": 1, "name": "John Investor", "email": "john@example.com", "types": ["real_estate", "car"]},            {"id": 2, "name": "Jane Wholesaler", "email": "jane@example.com", "types": ["real_estate"]},        ],        "total": 2    }if __name__ == "__main__":    import uvicorn    uvicorn.run(app, host="0.0.0.0", port=8000)
