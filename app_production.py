"""VORTEXAI PRODUCTION BACKEND - IN-MEMORY ONLYMinimal version focusing on in-memory storage"""from fastapi import FastAPIfrom fastapi.middleware.cors import CORSMiddlewarefrom datetime import datetimeimport logginglogging.basicConfig(level=logging.INFO)logger = logging.getLogger(__name__)# IN-MEMORY STORAGE - PRIMARY STORAGEdeals_in_memory = []app = FastAPI(title="VortexAI Deal Platform", version="2.0.0")app.add_middleware(    CORSMiddleware,    allow_origins=["*"],    allow_credentials=True,    allow_methods=["*"],    allow_headers=["*"],)@app.get("/health")async def health_check():    return {        "status": "operational",        "service": "VortexAI",        "version": "2.0.0",        "memory_deals": len(deals_in_memory),        "timestamp": datetime.now().isoformat()    }@app.get("/")async def root():    return {        "message": "VortexAI Deal Platform API v2.0",        "version": "2.0.0",        "memory_deals": len(deals_in_memory)    }@app.post("/admin/webhooks/deal-ingest")async def ingest_deal(data: dict):    """Store deal in memory"""    try:        name = data.get('name', 'Unknown')        email = data.get('email', 'unknown@local')        asset_type = data.get('asset_type', 'real_estate')        location = data.get('location', 'Unknown')        price = int(data.get('price', 0))        url = data.get('url', None)        source = data.get('source', 'manual')                deal_id = len(deals_in_memory) + 1        deal_obj = {            'id': deal_id,            'name': name,            'email': email,            'asset_type': asset_type,            'location': location,            'price': price,            'url': url,            'source': source,            'ai_score': 75.0 + (hash(name) % 25),            'urgency_level': 'high',            'created_at': datetime.now().isoformat()        }                deals_in_memory.append(deal_obj)        logger.info(f" Deal #{deal_id} stored: {name} | ${price} | {location}")                return {            "status": "success",            "message": "Deal ingested and stored",            "deal_id": deal_id,            "total_deals": len(deals_in_memory),            "ai_score": deal_obj['ai_score']        }    except Exception as e:        logger.error(f"Ingest error: {e}")        return {"status": "error", "error": str(e)}@app.get("/admin/deals")async def list_deals(skip: int = 0, limit: int = 100):    """List all deals from memory"""    try:        total = len(deals_in_memory)        deals_subset = deals_in_memory[skip:skip+limit]                logger.info(f" GET /admin/deals - Returning {len(deals_subset)} of {total} deals")                return {            "status": "success",            "deals": deals_subset,            "total": total,            "skip": skip,            "limit": limit,            "source": "in-memory"        }    except Exception as e:        logger.error(f"Error listing deals: {e}")        return {            "status": "error",            "deals": [],            "error": str(e)        }@app.get("/admin/kpis")async def get_kpis():    """Get KPI metrics"""    try:        high_score = sum(1 for d in deals_in_memory if d.get('ai_score', 0) >= 70)        total_value = sum(d.get('price', 0) for d in deals_in_memory)        avg_price = total_value / len(deals_in_memory) if deals_in_memory else 0                return {            "status": "success",            "total_deals": len(deals_in_memory),            "posted_today": len(deals_in_memory),            "high_score_deals": high_score,            "average_price": int(avg_price),            "total_value": total_value        }    except Exception as e:        logger.error(f"Error getting KPIs: {e}")        return {            "status": "error",            "total_deals": 0        }@app.get("/api/deals")async def get_top_deals(limit: int = 50):    """Get top-scored deals"""    try:        sorted_deals = sorted(deals_in_memory, key=lambda x: x.get('ai_score', 0), reverse=True)        top_deals = sorted_deals[:limit]        return {            "status": "success",            "deals": top_deals,            "total": len(top_deals)        }    except Exception as e:        logger.error(f"Error getting top deals: {e}")        return {"status": "error", "deals": []}@app.get("/api/buyers")async def get_buyers():    """Get buyer list"""    return {        "status": "success",        "buyers": [],        "total": 0    }if __name__ == "__main__":    import uvicorn    uvicorn.run(app, host="0.0.0.0", port=8000)
